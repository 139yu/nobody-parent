## 13.3 基于URL地址的权限管理

基于URL地址的权限管理主要通过FilterSecurityInterceptor来实现。如果配置了基于URL地址的权限管理，FilterSecurityInterceptor会自动添加到Spring Security过滤器链中；

请求被拦截后会交给AccessDecisionManager进行处理。

### 13.3.1基本用法

用户不能同时与角色和权限相关联，在Spring Security提供的User类中，两种方式最终都会调用User#authorities(Collection<? extends GrantedAuthority>)方法，最终后者
会覆盖前者。

示例：
```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("admin").roles("ADMIN").password("{noop}123")
                .and().withUser("test").authorities("test").password("{noop}123")
                .and().withUser("user").roles("USER").password("{noop}123");
    }
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                //必须具备ADMIN角色才能访问
                .antMatchers("/auth/admin/**").hasRole("ADMIN")
                //具备ADMIN或者USER角色才能访问
                .antMatchers("/auth/user/**").access("hasAnyRole('ADMIN','USER')")
                //拥有test权限才能访问
                .antMatchers("/auth/test/**").hasAnyAuthority("test")
                //其余请求认证后才能访问
                .anyRequest().access("isAuthenticated()")
                .and().formLogin().and().csrf().disable();
    }
}
```
注意事项： 

1.hasRole、hasAnyAuthority等方法最终都会转化为表达式

2.可通过access方法来使用权限表达式

3.当请求到达后，会按照从上往下顺序匹配，所以权限配置顺序很重要

### 13.3.2 角色继承

配置角色继承只需要提供RoleHierarchy实例：

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("admin").roles("ADMIN").password("{noop}123")
                .and().withUser("test").authorities("test").password("{noop}123")
                .and().withUser("user").roles("USER").password("{noop}123");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                //必须具备ADMIN角色才能访问
                .antMatchers("/auth/admin/**").hasRole("ADMIN")
                //具备ADMIN或者USER角色才能访问
                .antMatchers("/auth/user/**").access("hasAnyRole('ADMIN','USER')")
                //拥有test权限才能访问
                .antMatchers("/auth/test/**").hasAnyAuthority("test")
                //其余请求认证后才能访问
                .anyRequest().access("isAuthenticated()")
                .and().formLogin().and().csrf().disable();
    }

    @Bean
    RoleHierarchy roleHierarchy(){
        RoleHierarchyImpl hierarchy = new RoleHierarchyImpl();
        hierarchy.setHierarchy("ROLE_ADMIN > ROLE_USER");
        return hierarchy;
    }
}
```

ROLE_ADMIN继承紫ROLE_USER，具备ROLE_USER的权限

### 13.3.3自定义表达式

如下，登录必须为nobody才可访问：
```java
@Component
public class PermissionExpression {
    public boolean check(HttpServletRequest req){
        return "nobody".equals(req.getParameter("username"));
    }
}

```

在SecurityConfig中配置：
```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("admin").roles("ADMIN").password("{noop}123")
                .and().withUser("test").authorities("test").password("{noop}123")
                .and().withUser("user").roles("USER").password("{noop}123");
    }[ja-netfilter.jar](..%2F..%2Fja-netfilter%2Fja-netfilter.jar)

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                //必须具备ADMIN角色才能访问
                .antMatchers("/auth/admin/**").hasRole("ADMIN")
                //具备ADMIN或者USER角色才能访问
                .antMatchers("/auth/user/**").access("hasAnyRole('ADMIN','USER')")
                //拥有test权限才能访问
                .antMatchers("/auth/test/**").hasAnyAuthority("test")
                .antMatchers("/auth/customer/**").access("isAuthenticated() and permissionExpression.check(httpServletRequest)")
                //其余请求认证后才能访问
                .anyRequest().access("isAuthenticated()")
                .and().formLogin().and().csrf().disable();
    }
}
```

### 13.3.4 原理分析 

- AbstractSecurityInterceptor

AbstractSecurityInterceptor统筹着关于权处理的一切，主要方法：beforeInvocation、afterInvocation、finallyInvocation。

- FilterSecurityInterceptor
    
使用基于URL地址的权限管理，此时使用的是AbstractSecurityInterceptor的子类FilterSecurityInterceptor。在configure(HttpSecurity)方法中调用
http.authorizeRequests()开启URL路径拦截规则配置时，就会通过AbstractInterceptUrlConfigurer#configure方法将FilterSevurityInterceptor添加到Spring Security过滤器链中

- AbstractInterceptorUrlConfigurer
    
AbstractInterceptorUrlConfigurer主要用于创建FilterSecurityInterceptor，它有两个子类：ExpressionUrlAuthorizationConfigurer、UrlAuthorizationConfigurer。构建出来的
FilterSecurityInterceptor所使用的投票器和权限影视剧对象不一样，ExpressionUrlAuthorizationConfigurer支持表达式，但至少配置一对URL地址和权限之间的映射关系，UrlAuthorizationConfigurer不支持表达式。
UrlAuthorizationConfigurer配置FilterSecurityInterceptor需要手动创建一个UrlAuthorizationConfigurer：
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    
    ApplicationContext applicationContext = http.getSharedObject(ApplicationContext.class);
    http
            .apply(new UrlAuthorizationConfigurer<>(applicationContext))
            .getRegistry()
            //角色ROLE前缀必须加上
            .mvcMatchers("/admin/**").access("ROLE_ADMIN")
            .mvcMatchers("/user/**").access("ROLE_USER");
    http.formLogin().and().csrf().disable();
}
```
并且映射关系要确保完整，不然会出错，如下：
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    
    ApplicationContext applicationContext = http.getSharedObject(ApplicationContext.class);
    http
            .apply(new UrlAuthorizationConfigurer<>(applicationContext))
            .getRegistry()
            .mvcMatchers("/admin/**").access("ROLE_ADMIN")
            .mvcMatchers("/user/**");
    http.formLogin().and().csrf().disable();
}
```

### 13.3.5 动态管理权限规则

模块：`nobody-study/nobody-dynamic-auth`

## 13.4基于方法的权限管理

### 13.4.1注解介绍

通过@EnableGlobalMethodSecurity注解开启权限注解的使用：

```java
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true,jsr250Enabled = true)
public class SecurityConfig {
}
```
注解属性介绍：

- prePostEnabled：开启Spring Security提供的四个权限注解，@PreAuthorize、@PostAuthorize、@PreFilter、@PostFilter
- securedEnabled：开启Spring Security提供的两个权限注解，@Secured，不支持权限表达式
- jsr250Enabled：开启JSR-250提供的权限注解，主要包括@RolesAllowed、@DenyAll、@PermitAll，不支持权限表达式

注解介绍：

- @PreAuthorize：在目标方法之前之后进行权限校验
- @PostFilter：在目标方法执行之后对返回结果进行过滤
- @PreAuthorize：在目标方法之前进行权限校验
- @PreFilter：在目标方法执行之前对参数进行过滤
- @Secured：访问目标方法必须具备相应的角色
- @DenyAll：拒绝所有访问
- @PermitAll：允许所有访问
- @RolesAllowed：访问目标方法必须具备相应的角色

一般`prePostEnable=true`够用

### 13.4.2基本用法

- @PreAuthorize示例
- 
```java
@Service
public class HelloService {
    @PreAuthorize("hasRole('ADMIN') and authentication.name==#username")
    public String hello(String username){
        return "hello";
    }
}
```
通过`#`可以引用方法的参数

- PreFilter示例

```java
@Service
public class HelloService {
    @PreFilter(value = "filterObject.id%2!=0",filterTarget = "users")
    public void addUser(List<User> users, Integer other){
        for (User user : users) {
            System.out.println(user);
        }
    }
}
```
filterObject是一个内置对象，filterTarget是过滤的目标对象，如果方法只有一个参数，filterObject就代表这参数，如果有多个，需要通过filterTarget指定

这里只会打印id为奇数的用户

- @PostAuthorize示例

```java
@Service
public class HelloService {
    @PostAuthorize("returnObject.id==1")
    public User getUser(Integer id){
        return new User(id,"admin","123456");
    }
}
```
返回的id必须为1，否则抛出异常；此注解在ACL权限模型中会用到

- @PostFilter示例

```java
public class HelloService {
@PostFilter("filterObject.id%2!=0")
    public List<User> getAllUser(){
        List<User> list = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            list.add(new User(i,"admin"+i,"123456"));
        }
        return list;
    }
}
```
效果同@PreFilter

- @Secured示例

```java
public class HelloService {
    //表示用户需要具备ROLE_ADMIN,ROLE_USER两个角色才能访问
    @Secured({"ROLE_ADMIN", "ROLE_USER"})
    public User getUserByUsername(String username) {
        return new User(1, "admin", "123456");
    }
}
```
@Secured不支持权限表达式

- @RolesAllowed示例
- 
```java
public class HelloService {
    @RolesAllowed({"ADMIN","USER"})
    public String rolesAllowed(){
        return "rolesAllowed";
    }
}
```
RolesAllowed是jsr-250提供的注解，可以添加方法上，也可添加在类上，添加在类上对所有方法都有效，如果类上和方法上都有，则以方法上的注解为准