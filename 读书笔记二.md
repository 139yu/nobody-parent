## 13.3 基于URL地址的权限管理

基于URL地址的权限管理主要通过FilterSecurityInterceptor来实现。如果配置了基于URL地址的权限管理，FilterSecurityInterceptor会自动添加到Spring Security过滤器链中；

请求被拦截后会交给AccessDecisionManager进行处理。

### 13.3.1基本用法

用户不能同时与角色和权限相关联，在Spring Security提供的User类中，两种方式最终都会调用User#authorities(Collection<? extends GrantedAuthority>)方法，最终后者
会覆盖前者。

示例：
```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("admin").roles("ADMIN").password("{noop}123")
                .and().withUser("test").authorities("test").password("{noop}123")
                .and().withUser("user").roles("USER").password("{noop}123");
    }
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                //必须具备ADMIN角色才能访问
                .antMatchers("/auth/admin/**").hasRole("ADMIN")
                //具备ADMIN或者USER角色才能访问
                .antMatchers("/auth/user/**").access("hasAnyRole('ADMIN','USER')")
                //拥有test权限才能访问
                .antMatchers("/auth/test/**").hasAnyAuthority("test")
                //其余请求认证后才能访问
                .anyRequest().access("isAuthenticated()")
                .and().formLogin().and().csrf().disable();
    }
}
```
注意事项： 

1.hasRole、hasAnyAuthority等方法最终都会转化为表达式

2.可通过access方法来使用权限表达式

3.当请求到达后，会按照从上往下顺序匹配，所以权限配置顺序很重要

### 13.3.2 角色继承

配置角色继承只需要提供RoleHierarchy实例：

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("admin").roles("ADMIN").password("{noop}123")
                .and().withUser("test").authorities("test").password("{noop}123")
                .and().withUser("user").roles("USER").password("{noop}123");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                //必须具备ADMIN角色才能访问
                .antMatchers("/auth/admin/**").hasRole("ADMIN")
                //具备ADMIN或者USER角色才能访问
                .antMatchers("/auth/user/**").access("hasAnyRole('ADMIN','USER')")
                //拥有test权限才能访问
                .antMatchers("/auth/test/**").hasAnyAuthority("test")
                //其余请求认证后才能访问
                .anyRequest().access("isAuthenticated()")
                .and().formLogin().and().csrf().disable();
    }

    @Bean
    RoleHierarchy roleHierarchy(){
        RoleHierarchyImpl hierarchy = new RoleHierarchyImpl();
        hierarchy.setHierarchy("ROLE_ADMIN > ROLE_USER");
        return hierarchy;
    }
}
```

ROLE_ADMIN继承紫ROLE_USER，具备ROLE_USER的权限

### 13.3.3自定义表达式

如下，登录必须为nobody才可访问：
```java
@Component
public class PermissionExpression {
    public boolean check(HttpServletRequest req){
        return "nobody".equals(req.getParameter("username"));
    }
}

```

在SecurityConfig中配置：
```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("admin").roles("ADMIN").password("{noop}123")
                .and().withUser("test").authorities("test").password("{noop}123")
                .and().withUser("user").roles("USER").password("{noop}123");
    }[ja-netfilter.jar](..%2F..%2Fja-netfilter%2Fja-netfilter.jar)

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                //必须具备ADMIN角色才能访问
                .antMatchers("/auth/admin/**").hasRole("ADMIN")
                //具备ADMIN或者USER角色才能访问
                .antMatchers("/auth/user/**").access("hasAnyRole('ADMIN','USER')")
                //拥有test权限才能访问
                .antMatchers("/auth/test/**").hasAnyAuthority("test")
                .antMatchers("/auth/customer/**").access("isAuthenticated() and permissionExpression.check(httpServletRequest)")
                //其余请求认证后才能访问
                .anyRequest().access("isAuthenticated()")
                .and().formLogin().and().csrf().disable();
    }
}
```

### 13.3.4 原理分析 

- AbstractSecurityInterceptor

AbstractSecurityInterceptor统筹着关于权处理的一切，主要方法：beforeInvocation、afterInvocation、finallyInvocation。

- FilterSecurityInterceptor
    
使用基于URL地址的权限管理，此时使用的是AbstractSecurityInterceptor的子类FilterSecurityInterceptor。在configure(HttpSecurity)方法中调用
http.authorizeRequests()开启URL路径拦截规则配置时，就会通过AbstractInterceptUrlConfigurer#configure方法将FilterSevurityInterceptor添加到Spring Security过滤器链中

- AbstractInterceptorUrlConfigurer
    
AbstractInterceptorUrlConfigurer主要用于创建FilterSecurityInterceptor，它有两个子类：ExpressionUrlAuthorizationConfigurer、UrlAuthorizationConfigurer。构建出来的
FilterSecurityInterceptor所使用的投票器和权限影视剧对象不一样，ExpressionUrlAuthorizationConfigurer支持表达式，但至少配置一对URL地址和权限之间的映射关系，UrlAuthorizationConfigurer不支持表达式。
UrlAuthorizationConfigurer配置FilterSecurityInterceptor需要手动创建一个UrlAuthorizationConfigurer：
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    
    ApplicationContext applicationContext = http.getSharedObject(ApplicationContext.class);
    http
            .apply(new UrlAuthorizationConfigurer<>(applicationContext))
            .getRegistry()
            //角色ROLE前缀必须加上
            .mvcMatchers("/admin/**").access("ROLE_ADMIN")
            .mvcMatchers("/user/**").access("ROLE_USER");
    http.formLogin().and().csrf().disable();
}
```
并且映射关系要确保完整，不然会出错，如下：
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    
    ApplicationContext applicationContext = http.getSharedObject(ApplicationContext.class);
    http
            .apply(new UrlAuthorizationConfigurer<>(applicationContext))
            .getRegistry()
            .mvcMatchers("/admin/**").access("ROLE_ADMIN")
            .mvcMatchers("/user/**");
    http.formLogin().and().csrf().disable();
}
```

### 13.3.5 动态管理权限规则