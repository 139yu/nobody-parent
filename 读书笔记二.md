## 13.3 基于URL地址的权限管理

基于URL地址的权限管理主要通过FilterSecurityInterceptor来实现。如果配置了基于URL地址的权限管理，FilterSecurityInterceptor会自动添加到Spring Security过滤器链中；

请求被拦截后会交给AccessDecisionManager进行处理。

### 13.3.1基本用法

用户不能同时与角色和权限相关联，在Spring Security提供的User类中，两种方式最终都会调用User#authorities(Collection<? extends GrantedAuthority>)方法，最终后者
会覆盖前者。

示例：
```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("admin").roles("ADMIN").password("{noop}123")
                .and().withUser("test").authorities("test").password("{noop}123")
                .and().withUser("user").roles("USER").password("{noop}123");
    }
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                //必须具备ADMIN角色才能访问
                .antMatchers("/auth/admin/**").hasRole("ADMIN")
                //具备ADMIN或者USER角色才能访问
                .antMatchers("/auth/user/**").access("hasAnyRole('ADMIN','USER')")
                //拥有test权限才能访问
                .antMatchers("/auth/test/**").hasAnyAuthority("test")
                //其余请求认证后才能访问
                .anyRequest().access("isAuthenticated()")
                .and().formLogin().and().csrf().disable();
    }
}
```
注意事项： 

1.hasRole、hasAnyAuthority等方法最终都会转化为表达式

2.可通过access方法来使用权限表达式

3.当请求到达后，会按照从上往下顺序匹配，所以权限配置顺序很重要

### 13.3.2角色继承

如果要配置角色继承，只需提供RoleHierarchy实例

### 13.3.3自定义表达式

