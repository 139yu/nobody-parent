## 13.3 基于URL地址的权限管理

基于URL地址的权限管理主要通过FilterSecurityInterceptor来实现。如果配置了基于URL地址的权限管理，FilterSecurityInterceptor会自动添加到Spring Security过滤器链中；

请求被拦截后会交给AccessDecisionManager进行处理。

### 13.3.1基本用法

用户不能同时与角色和权限相关联，在Spring Security提供的User类中，两种方式最终都会调用User#authorities(Collection<? extends GrantedAuthority>)方法，最终后者
会覆盖前者。

示例：
```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("admin").roles("ADMIN").password("{noop}123")
                .and().withUser("test").authorities("test").password("{noop}123")
                .and().withUser("user").roles("USER").password("{noop}123");
    }
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                //必须具备ADMIN角色才能访问
                .antMatchers("/auth/admin/**").hasRole("ADMIN")
                //具备ADMIN或者USER角色才能访问
                .antMatchers("/auth/user/**").access("hasAnyRole('ADMIN','USER')")
                //拥有test权限才能访问
                .antMatchers("/auth/test/**").hasAnyAuthority("test")
                //其余请求认证后才能访问
                .anyRequest().access("isAuthenticated()")
                .and().formLogin().and().csrf().disable();
    }
}
```
注意事项： 

1.hasRole、hasAnyAuthority等方法最终都会转化为表达式

2.可通过access方法来使用权限表达式

3.当请求到达后，会按照从上往下顺序匹配，所以权限配置顺序很重要

如果系统同时存在角色和权限，角色类可继承GrantedAuthority实现，权限可以是使用SimpleGrantedAuthority来实现，在定义用户类时将角色转换为权限即可。


```java
@Getter
@Setter
public class Role implements GrantedAuthority {
    private String name;
    private List<SimpleGrantedAuthority> allowedOperations = new ArrayList<>();

    @Override
    public String getAuthority() {
        return this.name;
    }
}
```

